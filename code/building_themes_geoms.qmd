---
title: "Building Ggplot2 Themes and Geoms"
author: "Michal Rackiewicz"
format: gfm
editor: visual
graphics: yes
execute: 
  warning: false
  error: false
---

## Building New Themes
```{r}
#| output: false
library(datasets)
library(dplyr)
library(ggplot2)
library(grid)
library(faraway)
library(magrittr)

data("worldcup")
data("airquality")
```

With the \`ggplot2\` package a theme object is used to store the modifications of several elements of a plot. Note that a \`theme\` object stores only non-data elements of a plot. By default \`ggplot2\` uses the \`theme_gray\`, a gray background with white grid lines.
Modifying an existing theme can be achieved via the `theme` function. We can wrap the attributes we want to modify inside one of the `element_*` functions:
`element_blank`: nothing
`element_line`: lines/axes
`element_rect`: borders and backgrounds
`element_text`: text elements

We will start with `theme_bw` and make some changes.
```{r}
wrldcp_scatter <- ggplot(data = worldcup, aes(Time, Shots)) +
  geom_point() +
  ggtitle("World Cup Scatterplot")

wrldcp_scatter + theme_bw()
```

```{r}
new_theme <- theme_bw() + theme(plot.title = element_text(color = "darkred"))

wrldcp_scatter + new_theme
```
To make further changes, we can inspect the elements of the `new_theme`:
```{r}
head(new_theme)
```
The elements of a theme are stored in a list, so we can access each element via the `$` operator. We will make changes to the attributes of the `panel.background` and the `panel.border`. First we will take a look at their respective default values. 
```{r}
new_theme$panel.background
new_theme$panel.border

new_theme <- new_theme +
  theme(panel.background = element_rect(fill = "lightgrey"),
        panel.border = element_rect(colour = "darkred", linewidth = 2))
```
```{r}
#| echo: false
wrldcp_scatter + new_theme
```
## Building New Geoms
Building a geom is a two step process.
Construct a new class specifying the attributes and functions of the new geom via the `ggproto()` function. All classes inherit from the `Geom` class.
From this, the new `geom_*`function is constructed and can be used to create a layer to a ggplot object.

The basic structure of the new class looks like this:
```{r}
#| eval: false
GeomNewPoint <- ggproto("GeomNewPoint", Geom,
        required_aes = c("x", "y"), #a character vector of required aesthetics
        default_aes = aes(shape = 1, color = "black"), #default values for certain aesthetics
        draw_key = draw_key_point,
        #a function used to draw the key in the legend. 
        # specified by a draw_key_* function
        draw_panel = function(data, panel_scales, coord) {
                ## Function that returns a grid grob that will 
                ## be plotted (this is where the real work occurs)
          coords <- coord$transform(data, panel_scales)
          
          # Print structure 
          str(coords)
          print(summary(coords))
          
          # Construct grid grob
          pointsGrob(
            x = coords$x,
            y = coords$y,
            pch = coords$shape
          )
        }
)
```
The `draw_panel`function has three arguments:
`data`: specifies the data frame containing the columns mapped to each of the aesthetics specified
`panel_scales`: list describing the x and y scales
`coord`: describes the coordinate system of the plot

Now we will write the function, which uses the new class to add a layer to a `ggplot` object.
```{r}
geom_newpoint <- function(mapping = NULL, data = NULL, stat = "identity",
                         position = "identity", na.rm = FALSE, 
                         show.legend = NA, inherit.aes = TRUE, ...) {
        ggplot2::layer(
                geom = GeomNewPoint, mapping = mapping,  
                data = data, stat = stat, position = position, 
                show.legend = show.legend, inherit.aes = inherit.aes,
                params = list(na.rm = na.rm, ...)
        )
}
```

Now when we apply the geom to a `ggplot` object we also print the `coords` object:
```{r}
ggplot(worldcup, aes(Time, Shots)) +
  geom_newpoint()
```
As we can see from the summary, x and y values have been scaled to be between 0 and 1. 

The new geom can be improved by adding automated transparency based on the density of the displayed points. We want to scale point transparency with the number of points displayed. 
```{r}
GeomAutoTransparent <- ggproto("GeomAutoTransparent", Geom,
        required_aes = c("x", "y"),
        default_aes = aes(shape = 19),
        draw_key = draw_key_point,
        draw_panel = function(data, panel_scales, coord) {
                ## Transform the data first
                coords <- coord$transform(data, panel_scales)
                
                ## Compute the alpha transparency factor based on the
                ## number of data points being plotted
                n <- nrow(data)
                if(n > 100 && n <= 200)
                        coords$alpha <- 0.3
                else if(n > 200)
                        coords$alpha <- 0.15
                else
                        coords$alpha <- 1
                ## Construct a grid grob
                grid::pointsGrob(
                        x = coords$x,
                        y = coords$y,
                        pch = coords$shape,
                        gp = grid::gpar(alpha = coords$alpha)
                )
        })

geom_transparent <- function(mapping = NULL, 
                             data = NULL, 
                             stat = "identity",
                             position = "identity",
                             ...,
                             na.rm = FALSE,
                             show.legend = NA, 
                             inherit.aes = TRUE) {
        ggplot2::layer(
                geom = GeomAutoTransparent, 
                mapping = mapping,  
                data = data, 
                stat = stat, 
                position = position, 
                show.legend = show.legend, 
                inherit.aes = inherit.aes,
                params = list(na.rm = na.rm, 
                              ...)
        )
}
```

```{r}
ggplot(worldcup, aes(Time, Shots)) +
  geom_transparent()
```
The transparency should decrease when we reduce the number of data points displayed.
```{r}
worldcup %>% 
  ggplot(aes(Time, Shots)) +
  facet_wrap(~ Position, ncol = 2) +
  geom_transparent() 
```
Incorporating the computation of the density metric inside a geom rather then computing it for each position offers the advantage that it is done automatically - irrespective of the grouping variable we choose. Also, this approach does not add any new columns to the data frame.

## Building a Stat
Computations can also be implemented in a *stat*, separating them from the `Geom` class.
A `Stat` class is created in a similar fashion as `Geoms`:
First, a new `Stat` class is created via the `ggproto()` function. Analogous to `geoms`, the new class inherits from the `Stat` class.
In a second step a new `stat_*` function is defined, which uses the new class.
```{r}
#| eval: false
StatNEW <- ggproto("StatNEW", Stat,
                   compute_group = <a function that does computations>,
                   # The `ompute_group parameter must return a data frame 
                   # for ggplot2 to refer to.
                   default_aes = aes(<default values for certain aesthetics>),
                   required_aes = <a character vector of required aesthetics>)
```

We can build a stat that computes the 95% confidence interval and present it in a format that can be used by `geom_segment`.
`Geom_segment` requires the `x`, `y`, `xend` and `yend` parameters, so we need to include those. 
```{r}
StatConfint <- ggproto("StatConfint", Stat,
                       compute_group = function(data, scales) {
                               ## Compute the line segment endpoints
                               x <- data$x
                               xend <- data$x
                               y <- data$y - 1.96 * data$stderr
                               yend <- data$y + 1.96 * data$stderr
                               
                               ## Return a new data frame
                               data.frame(x = x, xend = xend,
                                          y = y, yend = yend)
                       },
                       required_aes = c("x", "y", "stderr")
)

stat_confint<- function(mapping = NULL, data = NULL, geom = "segment",
                           position = "identity", na.rm = FALSE, 
                           show.legend = NA, inherit.aes = TRUE, ...) {
        ggplot2::layer(
                stat = StatConfInt, 
                data = data, 
                mapping = mapping, 
                geom = geom, 
                position = position, 
                show.legend = show.legend, 
                inherit.aes = inherit.aes,
                params = list(na.rm = na.rm, ...)
        )
}
```

Now we want to plot the mean ozone values by month from the `airquality` dataset. We also calculate the standard error (SE) from which we later construct the confidence intervals.
```{r}
monthly_airqual <- airquality %>% 
  filter(!is.na(Ozone)) %>% 
  group_by(Month) %>% 
  mutate(SD = sd(Ozone)) %>% 
  summarise(Ozone = mean(Ozone),
            SampleSize = n(),
            SE = mean(SD) / sqrt(SampleSize))

ggplot(monthly_airqual, aes(Month, Ozone)) +
  geom_point() 
```
Now we construct the CI.
```{r}
ggplot(data = monthly_airqual, aes(x = Month, y = Ozone, stderr = SE)) + 
        geom_point() + 
        ylab("Ozone (ppb)") + 
        geom_segment(stat = "confint")
  
```

### Combining Geoms and Stats
